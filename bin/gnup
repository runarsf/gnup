#!/usr/bin/env bash
# https://trello.com/b/QwNLllss/gnup
set -o errexit
#set -o pipefail
#set -o noclobber
#set -o nounset
#set -o xtrace

colours () { # {{{
  export RESET=$'\e[0;39m'

  export E_BOLD=$'\e[1m'
  export E_DIM=$'\e[2m'
  export E_UNDERLINE=$'\e[4m'
  export E_BLINK=$'\e[5m'
  export E_INVERT=$'\e[7m'
  export E_HIDDEN=$'\e[8m'

  export R_NORMAL=$'\e[0m'
  export R_BOLD=$'\e[21m'
  export R_DIM=$'\e[22m'
  export R_UNDERLINE=$'\e[24m'
  export R_BLINK=$'\e[25m'
  export R_INVERT=$'\e[27m'
  export R_HIDDEN=$'\e[28m'

  export C_DEFAULT=$'\e[19m'
  export C_BLACK=$'\e[30m'
  export C_RED=$'\e[31m'
  export C_GREEN=$'\e[32m'
  export C_YELLOW=$'\e[33m'
  export C_BLUE=$'\e[34m'
  export C_MAGENTA=$'\e[35m'
  export C_CYAN=$'\e[36m'
  export C_LGRAY=$'\e[37m'
  export C_DGRAY=$'\e[90m'
  export C_LRED=$'\e[91m'
  export C_LGREEN=$'\e[92m'
  export C_LYELLOW=$'\e[93m'
  export C_LBLUE=$'\e[94m'
  export C_LMAGENTA=$'\e[95m'
  export C_LCYAN=$'\e[96m'
  export C_WHITE=$'\e[97m'

  export B_DEFAULT=$'\e[49m'
  export B_BLACK=$'\e[40m'
  export B_RED=$'\e[41m'
  export B_GREEN=$'\e[42m'
  export B_YELLOW=$'\e[43m'
  export B_BLUE=$'\e[44m'
  export B_MAGENTA=$'\e[45m'
  export B_CYAN=$'\e[46m'
  export B_LGRAY=$'\e[47m'
  export B_DGRAY=$'\e[100m'
  export B_LRED=$'\e[101m'
  export B_LGREEN=$'\e[102m'
  export B_LYELLOW=$'\e[103m'
  export B_LBLUE=$'\e[104m'
  export B_LMAGENTA=$'\e[105m'
  export B_LCYAN=$'\e[106m'
  export B_WHITE=$'\e[106m'
}
colours
# }}}

usage () { # {{{
	cat <<-EOMAN
	${RESET}${C_GREEN}Usage:${RESET} ${0}  <${C_RED}options${RESET}>  [${C_BLUE}commands-file${RESET}]
	
	${C_GREEN}Options:${RESET}
	  -h, --help               Display usage menu.
	  -q, --query     <${C_RED}query${RESET}>  Pre-fill query for selection menu.
	  -d, --defaults           Display default commands in selection.
	  -t, --text               Don't run command after selection, but print the product.
	  -s, --silent             Silence some messages.
	  -r, --rofi               Show rofi instead of fzf.
	
	${C_GREEN}Examples:${RESET}
	  ${0} ${C_RED}-r${RESET}
	  ${0} ${C_RED}--silent --defaults ${C_BLUE}~/.config/commands${RESET}
	${RESET}
	EOMAN
} # }}}

# Argument parsing {{{
# TODO: Add --create-default (create default commands file)
if test -p /dev/stdin; then
  STDIN_COMMANDS="$(cat)"
fi
positional=()
while test "${#}" -gt "0"; do
  case "${1}" in
    -h|--help)
      usage
      exit 0
      shift;;
    -q|--query)
      FZF_QUERY="${2}"
      shift;shift;;
    -d|--defaults)
      DEFAULT_COMMANDS=': Edit ${__type} commands file. ; ${EDITOR:-vim} ${__file}\n'
      shift;;
    -t|--text)
      OUTPUT_AS_TEXT="true"
      shift;;
    -s|--silent)
      SILENT="true"
      shift;;
    -r|--rofi)
      ROFI="true"
      shift;;
    --*)
      printf "Unknown option: ${1}\n"
      exit 1
      shift;;
    -*)
      shopts="${1}"
      if test "${#shopts}" -le "2"; then
        printf "Unknown option: ${shopts}\n"
        exit 2
      fi
      shift
      set -- "${shopts:0:2}" "-${shopts:2}" "${@}"
      ;;
    *)
      positional+=("${1}")
      shift;;
  esac
done

set -- "${positional[@]}"

if test "${#}" -gt "0"; then
  test -n "${SILENT}" || printf "Commands file(s): ${*}\n"
  # No support for multiple files (yet)
  COMMANDS_FILE="${1}"
fi
# }}}

select_commands_file () { # {{{
  commands_file="${1}"

  if test -z "${COMMANDS_FILE}"; then
    if test -f 'commands'; then
      commands_file="./commands"
      echo "1"
    elif (test -d '.git' || git rev-parse --is-inside-work-tree > /dev/null 2>&1) \
     && test -f "$(find -L -type f -name 'commands' 2> >(grep -v 'Permission denied' >&2))"; then
      commands_file="$(printf $(find -L -type f -name 'commands' 2> >(grep -v 'Permission denied' >&2)))"
      echo "2"
    elif test -f "${HOME}/.config/commands"; then
      commands_file="${HOME}/.config/commands"
      echo "3"
    elif test -f "${HOME}/.commands"; then
      commands_file="${HOME}/.commands"
      echo "4"
    else
      printf "No commands file found.\n"
      exit 1
    fi
  fi
  if ! test -f "$(realpath ${commands_file})"; then
    printf "Provided commands file not found.\n"
    exit 1
  fi

  printf "$(realpath ${commands_file})"
} # }}}

select_command () { # {{{
  commands_file="${1}"

  #IFS=$'\r\n'
  #GLOBIGNORE='*'
  #commands=("$(<${commands_file})")
  commands="${DEFAULT_COMMANDS}$(<${commands_file})"
  commands="$(printf "${commands}" | awk '{$1=$1};1')"
  lines=$(( "$(printf "${commands}" | wc -l)" + 1))

  if test -n "${ROFI}"; then
    cmd=$(rofi -lines ${lines} -i -dmenu "${@}" <<< ${commands})
  else
    cmd=$(\
      printf "${commands}" \
    | fzf --query="${FZF_QUERY}" --select-1 --exit-0
    )
  fi
  if test -n "${cmd}"; then
    printf "${cmd}"
  else
    exit 1
  fi
} # }}}

substitute_command () { # {{{
  cmd="${1}"
  while true; do
    # Check if anything left to replace
    [[ ${cmd} == *"<"*">"* ]] || break
    # Get the content of the first occurence of <this>
    index="$(echo ${cmd} | awk -F[\<\>] '{print $2}')"
    # Get substitution for <this>
    if test -n "${ROFI}"; then
      subst=$(echo "" | rofi -lines 0 -dmenu -p "${index}")
    else
      read -p "${index}> " subst
    fi
    test -z "${subst}" && subst="${index}"
    # Replace all occurences of <this>
    # Don't replace all when only <>
    #if [[ $b =~ "^.*<.*\S.*>.*$" ]]; then
      cmd="$(sed -E "s|(<${index}>)|${subst}|g" <<< ${cmd})"
    #else
    #  cmd="$(sed -E "s|(<${index}>)|${subst}|" <<< ${cmd})"
    #fi
  done
  printf "${cmd}"
} # }}}

utilize () { # {{{
  cmd="${1}"
  test -n "${SILENT}" || printf "$ ${cmd}\n\n"

  if test -n "${OUTPUT_AS_TEXT}"; then
    cmd="$(envsubst <<<${cmd})"
    printf "${cmd}"
  else
    eval "${cmd}"
  fi
} # }}}

commands_file="$(select_commands_file "${COMMANDS_FILE}")"
export __file="${commands_file}"
export __path="$(dirname "${__file}")"

selected_command="$(select_command "${commands_file}")"

substituted_command="$(substitute_command "${selected_command}")"

utilize "${substituted_command}"
