#!/usr/bin/env bash
# https://trello.com/b/QwNLllss/cmds
set -o errexit
#set -o pipefail
#set -o noclobber
#set -o nounset
#set -o xtrace

# Argument parsing {{{
# TODO: Add --create-default (create default commands file)
if test -p /dev/stdin; then
  STDIN_COMMANDS="$(cat)"
fi
positional=()
while test "${#}" -gt "0"; do
  case "${1}" in
    -q|--query)
      FZF_QUERY="${2}"
      shift;shift;;
    -d|--defaults)
      DEFAULT_COMMANDS=': Edit ${__type} commands file. ; ${EDITOR:-vim} ${__file}\n'
      shift;;
    -t|--text)
      OUTPUT_AS_TEXT="true"
      shift;;
    -s|--silent)
      SILENT="true"
      shift;;
    -f|--file)
      COMMANDS_FILE="${2}"
      shift;shift;;
    -r|--rofi)
      ROFI="true"
      shift;;
    --*)
      printf "Unknown option: ${1}\n"
      exit 1
      shift;;
    -*)
      shopts="${1}"
      if test "${#shopts}" -le "2"; then
        printf "Unknown option: ${shopts}\n"
        exit 2
      fi
      shift
      set -- "${shopts:0:2}" "-${shopts:2}" "${@}"
      ;;
    *)
      positional+=("${1}")
      shift;;
  esac
done

set -- "${positional[@]}"

#if test "${#}" -gt "0"; then
  #test -n "${SILENT}" || printf "Commands file(s): ${*}\n"
  # No support for multiple files (yet)
  #COMMANDS_FILE="${1}"
#fi
# }}}

select_commands_file () { # {{{
  COMMANDS_FILE="${1}"

  if test -z "${COMMANDS_FILE}"; then
    if test -f 'commands'; then
      commands_file="./commands"
    elif (test -d '.git' || git rev-parse --is-inside-work-tree > /dev/null 2>&1) \
     && test -f "$(find -L -type f -name 'commands' 2> >(grep -v 'Permission denied' >&2))"; then
      commands_file="$(printf $(find -L -type f -name 'commands' 2> >(grep -v 'Permission denied' >&2)))"
    elif test -f "${HOME}/.config/commands"; then
      commands_file="${HOME}/.config/commands"
    elif test -f "${HOME}/.commands"; then
      commands_file="${HOME}/.commands"
    else
      printf "No commands file found.\n"
      exit 1
    fi
  fi

  printf "$(realpath ${commands_file})"
} # }}}

select_command () { # {{{
  commands_file="${1}"

  #IFS=$'\r\n'
  #GLOBIGNORE='*'
  #commands=("$(<${commands_file})")
  commands="${DEFAULT_COMMANDS}$(<${commands_file})"
  commands="$(printf "${commands}" | awk '{$1=$1};1')"
  lines=$(( "$(printf "${commands}" | wc -l)" + 1))

  if test -n "${ROFI}"; then
    cmd=$(rofi -lines ${lines} -i -dmenu "${@}" <<< ${commands})
  else
    cmd=$(\
      printf "${commands}" \
    | fzf --query="${FZF_QUERY}" --select-1 --exit-0
    )
  fi
  if test -n "${cmd}"; then
    printf "${cmd}"
  else
    exit 1
  fi
} # }}}

substitute_command () { # {{{
  cmd="${1}"
  while true; do
    # Check if anything left to replace
    [[ ${cmd} == *"<"*">"* ]] || break
    # Get the content of the first occurence of <this>
    index="$(echo ${cmd} | awk -F[\<\>] '{print $2}')"
    # Get substitution for <this>
    if test -n "${ROFI}"; then
      subst=$(echo "" | rofi -lines 0 -dmenu -p "${index}")
    else
      read -p "${index}> " subst
    fi
    test -z "${subst}" && subst="${index}"
    # Replace all occurences of <this>
    # Don't replace all when only <>
    #if [[ $b =~ "^.*<.*\S.*>.*$" ]]; then
      cmd="$(sed -E "s|(<${index}>)|${subst}|g" <<< ${cmd})"
    #else
    #  cmd="$(sed -E "s|(<${index}>)|${subst}|" <<< ${cmd})"
    #fi
  done
  printf "${cmd}"
} # }}}

utilize () { # {{{
  cmd="${1}"
  test -n "${SILENT}" || printf "$ ${cmd}\n\n"

  if test -n "${OUTPUT_AS_TEXT}"; then
    cmd="$(envsubst <<<${cmd})"
    printf "${cmd}"
  else
    eval "${cmd}"
  fi
} # }}}

commands_file="$(select_commands_file "${COMMANDS_FILE}")"
export __file="${commands_file}"
export __path="$(dirname "${__file}")"

selected_command="$(select_command "${commands_file}")"

substituted_command="$(substitute_command "${selected_command}")"

utilize "${substituted_command}"
